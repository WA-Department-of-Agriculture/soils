---
title: "![](images/logos.png) Results from [INSERT PROJECT NAME]"
subtitle: "[INSERT DATE]"
execute:
  echo: false
  warning: false
  output: true
format: 
  html:
    link-external-newwindow: true
    embed-resources: true
    page-layout: full
    toc: true
    toc-depth: 4
    toc-location: left
    css: resources/styles.css
  docx:
    reference-doc: resources/word-template.docx
resource-path: 
  - inst
format-links: false
fig-align: left
fig-dpi: 300
params:
  producerId: WUY05
  year: 2023
---

```{r setup}
library(extrafont)
library(washi)
library(soils)

# global chunk options
knitr::opts_chunk$set(
  ft.align = "left",
  tbl.cap = NULL
)

# get output file type
out_type <- knitr::opts_knit$get("rmarkdown.pandoc.to")

# set path for saving figure output
path <- here::here("inst/figure_output/")

# create directory if needed
if (!dir.exists(path)) {
  dir.create(path)
}
```

```{r load-data}
# EDIT: You will need to add your own cleaned lab data to this data
# folder, using 'example_data.csv' as a template.
#
# 'data_dictionary.csv' must also be updated to match your own
# data set.

# Load lab results
data <- read.csv(
  here::here("inst/extdata/exampleData.csv"),
  check.names = FALSE
)

# Load data dictionary for pretty labels
dictionary <- read.csv(
  here::here("inst/extdata/dataDictionary.csv"),
  encoding = "UTF-8"
)

# If field name is blank, use field ID
data$fieldName <- ifelse(is.na(data$fieldName), data$fieldId, data$fieldName)

# If farm name is blank, use producer ID
data$farmName <- ifelse(is.na(data$farmName), data$producerId, data$farmName)
```

```{r subset-and-categorize}
# Subset to producer samples
producer_samples <- data |>
  subset(producerId == params$producerId & year == params$year)

# Identify measurements that producer has results for
cols_to_keep <- colSums(
  is.na(producer_samples)
) != nrow(producer_samples)

# Extract only measurements that producer has results for
producer_samples <- producer_samples[, cols_to_keep, drop = FALSE]

# Extract producer sample IDs, crops, counties, and farm name into
# producer list
producer <- list("sampleId", "crop", "county", "farmName") |>
  rlang::set_names() |>
  purrr::map(\(x) soils::pull_unique(
    df = producer_samples,
    target = x
  ))

# In case of multiple farm names, grab first one
producer$farmName <- producer$farmName[[1]]

# Add producer dataframe to producer list
producer <- list(info = producer, data = producer_samples)

# Prepare results dataframe with categories and sample labels
results <- data |>
  dplyr::mutate(
    .before = sampleId,
    # Dummy variable for strip plots
    dummy = "dummy",
    # Category variable for producer's samples, samples in same crop
    # or county, and others in the project
    category =
      dplyr::case_when(
        sampleId %in% producer$info$sampleId ~ "4producer",
        crop %in% producer$info$crop ~ "3sameCrop",
        county == producer$info$county ~ "2sameCounty",
        TRUE ~ "1other"
      )
  ) |>
  # Create sample labels for plot legend
  dplyr::mutate(
    .after = category,
    sampleLabel = dplyr::case_when(
      category == "producer" ~ paste(fieldName, "<br>Result:"),
      category %in% c("3sameCrop", "2sameCounty") ~ paste(
        county,
        crop,
        "Result:",
        sep = "<br>"
      ),
      TRUE ~ paste("Result:")
    )
  ) |>
  dplyr::arrange(category)

# Set category with correct factor level order this is important so
# producer's samples are plotted on top of the others
results$category <- factor(
  results$category,
  levels = c(
    "1other",
    "2sameCounty",
    "3sameCrop",
    "4producer"
  ),
  labels = c(
    "Other fields",
    "Same county",
    "Same crop",
    "Your fields"
  )
)
```

```{r lengthen-and-group}
# Tidy data into long format and join with data dictionary
results_long <- results |>
  dplyr::mutate(dplyr::across(dplyr::contains("_"), as.numeric)) |>
  tidyr::pivot_longer(
    cols = !c(
      dummy,
      category,
      sampleLabel,
      sampleId,
      farmName,
      producerName,
      producerId,
      fieldName,
      fieldId,
      county,
      crop,
      year,
      texture,
      longitude,
      latitude
    ),
    names_to = "measurement"
  ) |>
  dplyr::inner_join(dictionary, by = c("measurement" = "column_name")) |>
  dplyr::arrange(measurement_group, order) |>
  dplyr::mutate(
    abbr = factor(
      abbr,
      levels = dictionary$abbr,
      ordered = is.ordered(dictionary$order)
    ),
    abbr_unit = factor(
      abbr_unit,
      levels = dictionary$abbr_unit,
      ordered = is.ordered(dictionary$order)
    )
  )

# Get measurements tested for producer's fields
producer_measurements <- results_long |>
  subset(category == "Your fields" & !is.na(value)) |>
  soils::pull_unique(measurement)

# Subset results_long to exclude any measurements that the producer
# didn't have tested
results_long <- results_long |>
  subset(measurement %in% producer_measurements)

# Split df into list with each measurement group as its own df
groups <- results_long |>
  split(results_long$measurement_group)
```

```{r producer-tables}
# Subsets producer samples and pivots a measurement group
# df wider for use in tables

subset_widen_producer <- function(df) {
  df |>
    subset(category == "Your fields") |>
    dplyr::select(
      `Field or Average` = fieldName,
      abbr,
      value
    ) |>
    tidyr::pivot_wider(
      id_cols = `Field or Average`,
      names_from = abbr
    )
}

# Map function to each measurement group df, resulting in a new df
# containing producer's samples within a list
groups_producer <- groups |>
  rlang::set_names(paste0) |>
  purrr::map(subset_widen_producer)
```

```{r average-tables}
# This function calculates the county, crop, and project averages for
# each measurement group

group_averages <- function(data) {
  # By county
  n_county <- results |>
    subset(county %in% producer$info$county) |>
    dplyr::group_by(county) |>
    dplyr::summarize(n = dplyr::n_distinct(sampleId))

  county_texture <- groups$physical |>
    dplyr::group_by(county) |>
    dplyr::summarize(Texture = soils::calculate_mode(texture)) |>
    subset(county %in% producer$info$county)

  county <- data |>
    dplyr::group_by(abbr, county) |>
    dplyr::summarize(
      value = mean(value, na.rm = TRUE),
      .groups = "keep"
    ) |>
    subset(county %in% producer$info$county) |>
    dplyr::left_join(n_county) |>
    dplyr::left_join(county_texture) |>
    dplyr::mutate(
      `Field or Average` = paste0(
        county,
        " Average \n(",
        n,
        " Fields)"
      )
    ) |>
    dplyr::ungroup() |>
    dplyr::select(-c(county, n))

  # By crop
  n_crop <- results |>
    subset(crop %in% producer$info$crop) |>
    dplyr::group_by(crop) |>
    dplyr::summarize(n = dplyr::n_distinct(sampleId))

  crop_texture <- groups$physical |>
    dplyr::group_by(crop) |>
    dplyr::summarize(Texture = soils::calculate_mode(texture)) |>
    subset(crop %in% producer$info$crop)

  crop <- data |>
    dplyr::group_by(abbr, crop) |>
    dplyr::summarize(
      value = mean(value, na.rm = TRUE),
      .groups = "keep"
    ) |>
    subset(crop %in% producer$info$crop) |>
    dplyr::left_join(n_crop) |>
    dplyr::left_join(crop_texture) |>
    dplyr::mutate(
      `Field or Average` = paste0(
        crop,
        " Average \n(",
        n,
        " Fields)"
      )
    ) |>
    dplyr::ungroup() |>
    dplyr::select(-c(crop, n))

  # By project
  n_project <- results |>
    nrow()

  texture_project <- soils::calculate_mode(groups$physical$texture)

  project <- data |>
    dplyr::group_by(abbr) |>
    dplyr::summarize(
      value = mean(value, na.rm = TRUE),
      .groups = "keep"
    ) |>
    dplyr::mutate(
      "Field or Average" = paste0(
        "Project Average \n(",
        n_project,
        " Fields)"
      ),
      Texture = texture_project
    ) |>
    dplyr::ungroup()

  # Bind all together into one df
  dplyr::bind_rows(county, crop, project) |>
    dplyr::mutate(value = as.numeric(formatC(
      value,
      2,
      drop0trailing = TRUE
    ))) |>
    tidyr::pivot_wider(
      id_cols = c(`Field or Average`, Texture),
      names_from = abbr
    )
}

# Map function to each measurement group, resulting in new dfs of crop, county, project averages in a list
averages <- groups |>
  purrr::map(group_averages)

# Extract physical df from averages list
physical <- list(physical = averages$physical)

# Remove texture from all dataframes except physical
averages <- purrr::map(
  subset(
    averages,
    !(names(averages) == "physical")
  ),
  \(x) dplyr::select(x, -Texture)
)

# Add physical df back to the averages list
averages <- c(averages, physical)
```

```{r combine-producer-averages}
# Combine two lists into one
tables <- c(groups_producer, averages)

# Split the list by name then use bind rows to combine the df for each group
tables <- purrr::map(split(tables, names(tables)), dplyr::bind_rows)

# Delete any county or crop averages where n = 0
tables <- purrr::map(
  tables,
  subset,
  !grepl("(1 Fields)", `Field or Average`)
)
```

```{r headers}
# This function uses the data dictionary to create a new dataframe of
# the abbreviations and units for each measurement group for flextable
table_headers <- function(group) {
  dictionary |>
    subset(measurement_group == group) |>
    dplyr::select(abbr, unit) |>
    dplyr::mutate(key = abbr, .after = abbr) |>
    rbind(c("Field or Average", "Field or Average", ""))
}

# Map function to each measurement group, resulting in a new df with
# abbreviations and units in a list
headers <- results_long |>
  soils::pull_unique(target = measurement_group) |>
  as.list() |>
  rlang::set_names() |>
  purrr::map(table_headers)
```

## `r ifelse(!is.na(producer$info$farmName), producer$info$farmName, paste("Farm:", params$producerId))`

{{< include 01_project_summary.qmd >}}

\newpage

{{< include 02_soil_health_background.qmd >}}

\newpage

## Your Fields

```{r gis}
gis <- producer$data |>
  subset(!duplicated(sampleId)) |>
  dplyr::arrange(fieldId) |>
  dplyr::mutate(dplyr::across(
    dplyr::where(is.numeric),
    \(x) round(x, 4)
  )) |>
  dplyr::select(c(
    "Sample ID" = sampleId,
    "Field ID" = fieldId,
    "Field Name" = fieldName,
    "Crop" = crop,
    "Longitude" = longitude,
    "Latitude" = latitude
  )) |>
  dplyr::mutate(`Field ID` = as.character(`Field ID`))
```

```{r}
washi::washi_flextable(gis, cols_bold = 1)
```

```{r create-map}
map <- soils::make_leaflet(gis)
```

```{r save-map}
invisible(htmlwidgets::saveWidget(
  map,
  file = paste0(path, "map.html")
))
invisible(webshot::webshot(
  url = paste0(path, "map.html"),
  file = paste0(path, "map.png"),
))
```

```{r map-tip}
#| eval: !expr out_type == "html"
#| results: asis
cat("**Map Tip:** Click on the points to see the field ID, field name, and crop.")
```

```{r map-html}
#| eval: !expr out_type == "html"
map
```

```{r map-static}
#| eval: !expr out_type %in% c("pdf", "docx")
#| out-width: 6in
knitr::include_graphics(
  paste0(path, "/map.png")
)
```

```{r line-break}
#| eval: !expr out_type == "html"
#| results: asis
cat("<br>")
```

```{r map-download}
#| eval: !expr out_type == "html"
if ("downloadthis" %in% rownames(installed.packages())) {
  downloadthis::download_file(
    path = paste0(path, "map.png"),
    button_label = "Download map as .png",
    button_type = "success"
  )
}
```

\newpage

## Project Results

Below are tables and graphs describing the physical, biological, and chemical measurements from your soils. Each point represents a sample we collected. Take a look to see how your fields compare to others in the project. All samples were collected from \[INSERT SOIL DEPTH (e.g. 0-6 inches, or 0-30 cm)\].

```{r physical-header}
#| results: asis
cat("### <span style='color:#a60f2d'>Physical Measurements</span> ![](images/physical.png){height='50px'}")
```

```{r texture-wrangle}
# Wrangle physical data for the texture triangle
texture <- groups$physical |>
  subset(
    measurement %in% c("sand_%", "silt_%", "clay_%")
  ) |>
  dplyr::select(
    category,
    sampleId,
    Field = fieldName,
    Texture = texture,
    measurement,
    value
  ) |>
  tidyr::pivot_wider(
    id_cols = c(sampleId, category, Field, Texture),
    names_from = measurement
  ) |>
  dplyr::rename(
    Sand = `sand_%`,
    Silt = `silt_%`,
    Clay = `clay_%`
  ) |>
  dplyr::mutate(Field = as.character(Field))

# Modify physical table to include texture of producer fields and
# texture mode across county, crop, project
tables$physical <- texture |>
  subset(category == "Your fields") |>
  dplyr::select(Field, Texture) |>
  dplyr::full_join(
    tables$physical,
    by = c("Field" = "Field or Average")
  ) |>
  dplyr::mutate(
    Texture = ifelse(
      is.na(Texture.x),
      Texture.y,
      Texture.x
    ),
    .after = Field
  ) |>
  dplyr::rename(`Field or Average` = "Field") |>
  dplyr::select(-c(Texture.x, Texture.y))
```

```{r texture-triangle}
soils::texture_triangle(texture)
```

\newpage

```{r}
# do not add chunk label due to bug https://github.com/quarto-dev/quarto-cli/issues/3603
soils::make_ft("physical") |>
  # EDIT: adds border above merged unit cells.
  # may need to adjust column index
  soils::unit_hline(3)
```

```{r physical-plot-static}
#| eval: !expr out_type %in% c("pdf", "docx")
physical_plot <- soils::make_strip_plot(
  groups$physical,
  output = "static"
)

soils::save_plot(physical_plot, path = path)

knitr::include_graphics(
  paste0(path, "/physical_plot.png")
)
```

```{r plot-tips}
#| eval: !expr out_type == "html"
#| results: asis
cat("<span style='color:black'>**Plot Tips:** Hover over a point to see its value. Zoom in by drawing a box within a plot. Click on a legend item to show or hide those points.</span>")
```

```{r physical-plot-html}
#| eval: !expr out_type == "html"
#| fig-height: 6
soils::make_plotly(groups$physical)
```

\newpage

```{r biological-header}
#| results: asis
cat("### <span style='color:#335c67'>Biological Measurements</span> ![](images/biological.png){height='50px'}")
```

```{r}
# do not add chunk label due to bug https://github.com/quarto-dev/quarto-cli/issues/3603
soils::make_ft("biological")
```

```{r biological-plot-static}
#| eval: !expr out_type %in% c("pdf", "docx")
biological_plot <- soils::make_strip_plot(
  groups$biological,
  output = "static"
)

soils::save_plot(
  biological_plot,
  path = path
)

knitr::include_graphics(
  paste0(path, "/biological_plot.png")
)
```

```{r biological-plot-tips, ref.label=I("plot-tips")}
```

```{r biological-plot-html}
#| eval: !expr out_type == "html"
#| fig-height: 6
soils::make_plotly(groups$biological)
```

```{r chemical-header}
#| results: asis
cat("### <span style='color:#824d00'>Chemical Measurements</span> ![](images/chemical){height='50px'}")
```

```{r}
# do not add chunk label due to bug https://github.com/quarto-dev/quarto-cli/issues/3603
soils::make_ft("chemical") |>
  # EDIT: adds border above merged unit cells.
  # may need to adjust column index
  soils::unit_hline(c(5))
```

```{r chemical-plot-static}
#| eval: !expr out_type %in% c("pdf", "docx")
chemical_plot <- soils::make_strip_plot(
  groups$chemical,
  output = "static"
)

soils::save_plot(
  chemical_plot,
  path = path
)

knitr::include_graphics(
  paste0(path, "/chemical_plot.png")
)
```

```{r chemical-plot-tips, ref.label=I("plot-tips")}
```

```{r chemical-plot-html}
#| eval: !expr out_type == "html"
#| fig-height: 6
soils::make_plotly(groups$chemical)
```

```{r macro-header}
#| results: asis
cat("#### <span style='color:#824d00'>Plant Essential Macro Nutrients</span>")
```

```{r}
# do not add chunk label due to bug https://github.com/quarto-dev/quarto-cli/issues/3603
soils::make_ft("macro") |>
  # EDIT: adds border above merged unit cells.
  # may need to adjust column index
  soils::unit_hline(c(3))
```

```{r macro-plot-static}
#| eval: !expr out_type %in% c("pdf", "docx")
macro_plot <- soils::make_strip_plot(
  groups$macro,
  output = "static"
)

soils::save_plot(macro_plot, path = path)

knitr::include_graphics(
  paste0(path, "/macro_plot.png")
)
```

```{r macro-plot-tips, ref.label=I("plot-tips")}
```

```{r macro-plot-html}
#| eval: !expr out_type == "html"
#| fig-height: 6
soils::make_plotly(groups$macro)
```

```{r micro-header}
#| results: asis
cat("#### <span style='color:#824d00'>Plant Essential Micro Nutrients</span>")
```

```{r}
# do not add chunk label due to bug https://github.com/quarto-dev/quarto-cli/issues/3603
soils::make_ft("micro") |>
  # EDIT: adds border above merged unit cells.
  # may need to adjust column index
  soils::unit_hline(c(2))
```

```{r micro-plot-static}
#| eval: !expr out_type %in% c("pdf", "docx")
micro_plot <- soils::make_strip_plot(
  groups$micro,
  output = "static"
)

soils::save_plot(
  micro_plot,
  path = path
)

knitr::include_graphics(
  paste0(path, "/micro_plot.png")
)
```

```{r micro-plot-tips, ref.label=I("plot-tips")}
```

```{r micro-plot-html}
#| eval: !expr out_type == "html"
#| fig-height: 6
soils::make_plotly(groups$micro)
```

```{r download-data-text}
#| eval: !expr out_type == "html"
#| results: asis
if ("downloadthis" %in% rownames(installed.packages())) {
  cat("## Download your data")
}
```

```{r download-data}
#| eval: !expr out_type == "html"
if ("downloadthis" %in% rownames(installed.packages())) {
  list(
    results = producer_samples,
    measurement_dictionary = dictionary[
      ,
      c(
        "column_name",
        "measurement_full_name",
        "abbr",
        "unit"
      )
    ]
  ) |>
    downloadthis::download_this(
      output_name = "soils_data",
      output_extension = ".xlsx",
      button_label = "Download as Excel spreadsheet",
      button_type = "success"
    )
}
```

\newpage

## Looking Forward

{{< include 06_looking_forward.qmd >}}

## Acknowledgement

{{< include 07_acknowledgement.qmd >}}

```{js open-link-in-new-tab}

// https://yihui.org/en/2018/09/target-blank/

(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.leng; i) {
    if (/^(https?:)?\/\//.st(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
```
