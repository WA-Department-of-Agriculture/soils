---
title: "![](images/logos.png) Results from [INSERT PROJECT NAME]"
subtitle: "[INSERT DATE]"
params:
  producerId: 4
  year: 2022
execute:
  echo: false
  warning: false
  output: true
format: 
  html:
    link-external-newwindow: true
    embed-resources: true
    page-layout: full
    toc: true
    toc-depth: 4
    toc-location: left
    css: resources/styles.css
  docx:
    reference-doc: resources/word-template.docx
format-links: false
fig-align: left
fig-dpi: 300
---

```{r setup}
library(extrafont)
library(washi)
library(soils)

# global chunk options
knitr::opts_chunk$set(
  ft.align = "left",
  fig.showtext = TRUE,
  tbl.cap = NULL
)

# get output file type
out_type <- knitr::opts_knit$get("rmarkdown.pandoc.to")
```

```{r load-data}
# EDIT: You will need to add your own cleaned lab data to this data
# folder, using 'example_data.csv' as a template.
#
# 'data_dictionary.csv' must also be updated to match your own
# dataset.

# Load lab results
data <- read.csv(
  paste0(here::here(), "/inst/extdata/example_data_wide.csv"),
  check.names = FALSE
)
# Load data dictionary for pretty labels
dictionary <- read.csv(
  paste0(here::here(), "/inst/extdata/data_dictionary.csv"),
  encoding = "UTF-8"
)
```

```{r subset-and-categorize}
# Subset to producer samples
producer_samples <- data |>
  subset(producerId == params$producerId & year == params$year)

# Identify measurements that producer has results for
cols_to_keep <- colSums(
  is.na(producer_samples)
) != nrow(producer_samples)

# Extract only measurements that producer has results for
producer_samples <- producer_samples[, cols_to_keep, drop = FALSE]

# Extract producer sample IDs, crops, counties, and farm name into
# producer list
producer <- list("sampleId", "crop", "county", "farmName") |>
  rlang::set_names() |>
  purrr::map(\(x) soils::pull_unique(
    df = producer_samples,
    target = x
  ))

# In case of multiple farm names, grab first one
producer$farmName <- producer$farmName[[1]]

# Add producer dataframe to producer list
producer <- list(info = producer, data = producer_samples)

# Prepare results dataframe with categories and sample labels
results <- data |>
  dplyr::mutate(
    .before = sampleId,
    # Dummy variable for strip plots
    dummy = "dummy",
    # Category variable for producer's samples, samples in same crop
    # or county, and others in the project
    category =
      dplyr::case_when(
        sampleId %in% producer$info$sampleId ~ "producer",
        crop %in% producer$info$crop ~ "sameCrop",
        county == producer$info$county ~ "sameCounty",
        TRUE ~ "other"
      )
  ) |>
  # Create sample labels for plot legend
  dplyr::mutate(
    .after = category,
    sampleLabel = dplyr::case_when(
      category == "producer" ~ paste(fieldName, "<br>Result:"),
      category %in% c("sameCrop", "sameCounty") ~ paste(
        county, crop, "Result:",
        sep = "<br>"
      ),
      TRUE ~ paste("Result:")
    )
  )

# Set category with correct factor level order this is important so
# producer's samples are plotted on top of the others
results$category <- factor(
  results$category,
  levels = c(
    "other",
    "sameCounty",
    "sameCrop",
    "producer"
  ),
  labels = c(
    "Other fields",
    "Same county",
    "Same crop",
    "Your fields"
  )
)
```

```{r lengthen-and-group}
# Tidy data into long format and join with data dictionary
results_long <- results |>
  dplyr::mutate(dplyr::across(dplyr::contains("_"), as.numeric)) |>
  tidyr::pivot_longer(
    cols = !c(
      dummy, category, sampleLabel, sampleId, farmName,
      producerName, producerId, fieldName, fieldId, county, crop,
      year, texture, longitude, latitude
    ),
    names_to = "measurement"
  ) |>
  dplyr::inner_join(dictionary, by = c("measurement" = "column_name")) |>
  dplyr::arrange(measurement_group, order) |>
  dplyr::mutate(
    abbr = factor(abbr,
      levels = dictionary$abbr,
      ordered = is.ordered(dictionary$order)
    ),
    abbr_unit = factor(abbr_unit,
      levels = dictionary$abbr_unit,
      ordered = is.ordered(dictionary$order)
    )
  )

# Get measurements tested for producer's fields
producer_measurements <- results_long |>
  subset(category == "Your fields" & !is.na(value)) |>
  soils::pull_unique(measurement)

# Subset results_long to exclude any measurements that the producer
# didn't have tested
results_long <- results_long |>
  subset(measurement %in% producer_measurements)

# Split df into list with each measurement group as its own df
groups <- results_long |>
  split(results_long$measurement_group)
```

```{r producer-tables}
# Subsets producer samples and pivots a measurement group
# df wider for use in tables

subset_widen_producer <- function(df) {
  df |>
    subset(category == "Your fields") |>
    dplyr::select(
      `Field or Average` = fieldName, abbr, value
    ) |>
    tidyr::pivot_wider(
      id_cols = `Field or Average`, names_from = abbr
    )
}

# Map function to each measurement group df, resulting in a new df
# containing producer's samples within a list
groups_producer <- groups |>
  rlang::set_names(paste0) |>
  purrr::map(subset_widen_producer)
```

```{r average-tables}
# This function calculates the county, crop, and project averages for
# each measurement group

group_averages <- function(data) {
  # By county
  n_county <- results |>
    subset(county %in% producer$county) |>
    dplyr::group_by(county) |>
    dplyr::summarize(n = dplyr::n_distinct(sampleId))

  county_texture <- groups$physical |>
    dplyr::group_by(county) |>
    dplyr::summarize(Texture = soils::calculate_mode(texture)) |>
    subset(county %in% producer$county)

  county <- data |>
    dplyr::group_by(abbr, county) |>
    dplyr::summarize(
      value = mean(value, na.rm = TRUE),
      .groups = "keep"
    ) |>
    subset(county %in% producer$county) |>
    dplyr::left_join(n_county) |>
    dplyr::left_join(county_texture) |>
    dplyr::mutate(
      `Field or Average` = paste0(
        county,
        " Average \n(",
        n,
        " Fields)"
      )
    ) |>
    dplyr::ungroup() |>
    dplyr::select(-c(county, n))

  # By crop
  n_crop <- results |>
    subset(crop %in% producer$crop) |>
    dplyr::group_by(crop) |>
    dplyr::summarize(n = dplyr::n_distinct(sampleId))

  crop_texture <- groups$physical |>
    dplyr::group_by(crop) |>
    dplyr::summarize(Texture = soils::calculate_mode(texture)) |>
    subset(crop %in% producer$crop)

  crop <- data |>
    dplyr::group_by(abbr, crop) |>
    dplyr::summarize(
      value = mean(value, na.rm = TRUE),
      .groups = "keep"
    ) |>
    subset(crop %in% producer$crop) |>
    dplyr::left_join(n_crop) |>
    dplyr::left_join(crop_texture) |>
    dplyr::mutate(
      `Field or Average` = paste0(
        crop,
        " Average \n(",
        n,
        " Fields)"
      )
    ) |>
    dplyr::ungroup() |>
    dplyr::select(-c(crop, n))

  # By project
  n_project <- results |>
    nrow()

  texture_project <- soils::calculate_mode(groups$physical$texture)

  project <- data |>
    dplyr::group_by(abbr) |>
    dplyr::summarize(
      value = mean(value, na.rm = TRUE),
      .groups = "keep"
    ) |>
    dplyr::mutate(
      "Field or Average" = paste0(
        "Project Average \n(",
        n_project,
        " Fields)"
      ),
      Texture = texture_project
    ) |>
    dplyr::ungroup()

  # Bind all together into one df
  dplyr::bind_rows(county, crop, project) |>
    dplyr::mutate(value = as.numeric(formatC(value, 2,
      drop0trailing = TRUE
    ))) |>
    tidyr::pivot_wider(
      id_cols = c(`Field or Average`, Texture),
      names_from = abbr
    )
}

# Map function to each measurement group, resulting in a new dfs of crop, county, project averages in a list
averages <- groups |>
  purrr::map(group_averages)

# Extract physical df from averages list
physical <- list(physical = averages$physical)

# Remove texture from all dataframes except physical
averages <- purrr::map(
  subset(
    averages,
    !(names(averages) == "physical")
  ),
  \(x) dplyr::select(x, -Texture)
)

# Add physical df back to the averages list
averages <- c(averages, physical)
```

```{r combine-producer-averages}
# Combine two lists into one
tables <- c(groups_producer, averages)

# Split the list by name then use bind rows to combine the df for each group
tables <- purrr::map(split(tables, names(tables)), dplyr::bind_rows)

# Delete any county or crop averages where n = 0
tables <- purrr::map(
  tables,
  subset, !grepl("(1 Fields)", `Field or Average`)
)
```

```{r headers}
# This function uses the data dictionary to create a new dataframe of
# the abbreviations and units for each measurement group for flextable
table_headers <- function(group) {
  dictionary |>
    subset(measurement_group == group) |>
    dplyr::select(abbr, unit) |>
    dplyr::mutate(key = abbr, .after = abbr) |>
    rbind(c("Field or Average", "Field or Average", ""))
}

# Map function to each measurement group, resulting in a new df with
# abbreviations and units in a list
headers <- results_long |>
  soils::pull_unique(target = measurement_group) |>
  as.list() |>
  rlang::set_names() |>
  purrr::map(table_headers)
```

# `r ifelse(!is.na(producer$info$farmName), producer$info$farmName, paste("Farm:", params$producerId))`

\[INSERT DESCRIPTION OF YOUR PROJECT\] *Thank the participating farmer. Consider including information related to how many samples you've taken, in how many crops and regions. Consider identifying members of the project team and acknowledging support from your funders and collaborators. Emphasize the objectives of the project, and include links for more information.*

EXAMPLE: Thank you for being a participant in our [State of the Soils Assessment](https://agr.wa.gov/departments/land-and-water/natural-resources/soil-health/state-of-the-soils). This work would not be possible without your collaboration and input.

The goals of our project are to:

**1)** Assess baseline soil health in Washington;

**2)** Understand how climate, crop type, and management impact soil health;

**3)** Develop cost-effective ways for producers to assess their own soil health, and;

**4)** Develop crop- and region-specific decision support tools.

To date, the Washington State Department of Agriculture (WSDA), Washington State University (WSU), conservation districts, and agricultural professionals across Washington have sampled from nearly **700** fields planted in more than **50** crop types. We are excited to share with you some preliminary results with data from your fields.

\[INSERT IMAGE OF YOUR TEAM OR A SCENE FROM YOUR SAMPLING PROJECT\]

EXAMPLE:

![](https://raw.githack.com/WA-Department-of-Agriculture/soils/origin/inst/images/sampling_scene.png){width="550"}

\newpage

{{< include _soil_health_background.qmd >}}

\newpage

## Your Fields

```{r gis}
gis <- producer$data |>
  subset(!duplicated(sampleId)) |>
  dplyr::arrange(fieldId) |>
  dplyr::mutate(dplyr::across(
    dplyr::where(is.numeric),
    \(x) round(x, 4)
  )) |>
  dplyr::select(c(
    "Sample ID" = sampleId,
    "Field ID" = fieldId,
    "Field Name" = fieldName,
    "Crop" = crop,
    "Longitude" = longitude,
    "Latitude" = latitude
  )) |>
  dplyr::mutate(`Field ID` = as.character(`Field ID`))
```

```{r}
washi::washi_flextable(gis, cols_bold = 1)
```

```{r create-map}
map <- soils::map_samples(gis)
```

```{r save-map}
invisible(htmlwidgets::saveWidget(
  map,
  file = paste0(here::here(), "/inst/figure_output/map.html")
))
invisible(webshot::webshot(
  url = paste0(here::here(), "/inst/figure_output/map.html"),
  file = paste0(here::here(), "/inst/figure_output/map.png"),
))
```

```{r map-tip}
#| eval: !expr out_type == "html"
#| results: asis
cat("**Map Tip:** Click on the points to see the field ID, field name, and crop.")
```

```{r map-html}
#| eval: !expr out_type == "html"
map
```

```{r map-static}
#| eval: !expr out_type %in% c("pdf", "docx")
#| out-width: 6in
knitr::include_graphics(paste0(
  here::here(), "/inst/figure_output/map.png"
))
```

```{r line-break}
#| eval: !expr out_type == "html"
#| results: asis
cat("<br>")
```

```{r map-download}
#| eval: !expr out_type == "html"
downloadthis::download_file(
  path = paste0(here::here(), "/inst/figure_output/map.png"),
  button_label = "Download map as .png",
  button_type = "success"
)
```

\newpage

## Project Results

Below are tables and graphs describing the physical, biological, and chemical measurements from your soils. Each point represents a sample we collected. Take a look to see how your fields compare to others in the project. All samples were collected from \[INSERT SOIL DEPTH (e.g. 0-6 inches, or 0-30 cm)\].

```{r physical-header}
#| results: asis
cat("### <span style='color:#a60f2d'>Physical Measurements</span> ![](images/physical.png){height='50px'}")
```

```{r texture-wrangle}
# Texture is formatted for the texture triangle
texture <- groups$physical |>
  subset(measurement %in% c("sand_%", "silt_%", "clay_%")) |>
  dplyr::select(category,
    sampleId,
    Field = fieldName,
    Texture = texture,
    measurement,
    value
  ) |>
  tidyr::pivot_wider(
    id_cols = c(sampleId, category, Field, Texture),
    names_from = measurement
  ) |>
  dplyr::rename(
    Sand = `sand_%`,
    Silt = `silt_%`,
    Clay = `clay_%`
  ) |>
  dplyr::mutate(Field = as.character(Field))

# Modify physical table to include texture of producer fields and
# texture mode across county, crop, project
tables$physical <- texture |>
  subset(category == "Your fields") |>
  dplyr::select(Field, Texture) |>
  dplyr::full_join(tables$physical,
    by = c("Field" = "Field or Average")
  ) |>
  dplyr::mutate(
    Texture = ifelse(is.na(Texture.x), Texture.y, Texture.x),
    .after  = Field
  ) |>
  dplyr::rename(`Field or Average` = "Field") |>
  dplyr::select(-c(Texture.x, Texture.y))
```

```{r texture-triangle}
soils::texture_triangle(texture)
```

\newpage

```{r}
# do not add chunk label due to bug https://github.com/quarto-dev/quarto-cli/issues/3603
soils::make_ft("physical") |>
  # EDIT: adds border above merged unit cells.
  # may need to adjust column index
  soils::unit_hline(3)
```

```{r physical-plot-static}
#| eval: !expr out_type %in% c("pdf", "docx")
physical_plot <- soils::make_strip_plot(groups$physical, output = "static")
soils::save_plot(physical_plot, ext = "png", width = 6, height = 4)

knitr::include_graphics(
  paste0(
    here::here(), "/inst/figure_output/physical_plot.png"
  )
)
```

```{r plot-tips}
#| eval: !expr out_type == "html"
#| results: asis
cat("<span style='color:black'>**Plot Tips:** Hover over a point to see its value. Zoom in by drawing a box within a plot. Click on a legend item to show or hide those points.</span>")
```

```{r physical-plot-html}
#| eval: !expr out_type == "html"
#| fig-height: 6
soils::make_plotly(groups$physical)
```

\newpage

```{r biological-header}
#| results: asis
cat("### <span style='color:#335c67'>Biological Measurements</span> ![](images/biological.png){height='50px'}")
```

```{r}
# do not add chunk label due to bug https://github.com/quarto-dev/quarto-cli/issues/3603
soils::make_ft("biological")
```

```{r biological-plot-static}
#| eval: !expr out_type %in% c("pdf", "docx")
biological_plot <- soils::make_strip_plot(groups$biological, output = "static")
soils::save_plot(biological_plot, ext = "png", width = 6, height = 4)

knitr::include_graphics(
  paste0(
    here::here(), "/inst/figure_output/biological_plot.png"
  )
)
```

```{r biological-plot-tips, ref.label=I("plot-tips")}
```

```{r biological-plot-html}
#| eval: !expr out_type == "html"
#| fig-height: 6
soils::make_plotly(groups$biological)
```

```{r chemical-header}
#| results: asis
cat("### <span style='color:#d4820a'>Chemical Measurements</span> ![](images/chemical){height='50px'}")
```

```{r}
# do not add chunk label due to bug https://github.com/quarto-dev/quarto-cli/issues/3603
soils::make_ft("chemical") |>
  # EDIT: adds border above merged unit cells.
  # may need to adjust column index
  soils::unit_hline(c(5))
```

```{r chemical-plot-static}
#| eval: !expr out_type %in% c("pdf", "docx")
chemical_plot <- soils::make_strip_plot(groups$chemical, output = "static")
soils::save_plot(chemical_plot, ext = "png", width = 6, height = 4)

knitr::include_graphics(
  paste0(
    here::here(), "/inst/figure_output/chemical_plot.png"
  )
)
```

```{r chemical-plot-tips, ref.label=I("plot-tips")}
```

```{r chemical-plot-html}
#| eval: !expr out_type == "html"
#| fig-height: 6
soils::make_plotly(groups$chemical)
```

```{r macro-header}
#| results: asis
cat("#### <span style='color:#d4820a'>Plant Essential Macro Nutrients</span>")
```

```{r}
# do not add chunk label due to bug https://github.com/quarto-dev/quarto-cli/issues/3603
soils::make_ft("macro") |>
  # EDIT: adds border above merged unit cells.
  # may need to adjust column index
  soils::unit_hline(c(3))
```

```{r macro-plot-static}
#| eval: !expr out_type %in% c("pdf", "docx")
macro_plot <- soils::make_strip_plot(groups$macro, output = "static")
soils::save_plot(macro_plot, ext = "png", width = 6, height = 4)

knitr::include_graphics(
  paste0(
    here::here(), "/inst/figure_output/macro_plot.png"
  )
)
```

```{r macro-plot-tips, ref.label=I("plot-tips")}
```

```{r macro-plot-html}
#| eval: !expr out_type == "html"
#| fig-height: 6
soils::make_plotly(groups$macro)
```

```{r micro-header}
#| results: asis
cat("#### <span style='color:#d4820a'>Plant Essential Micro Nutrients</span>")
```

```{r}
# do not add chunk label due to bug https://github.com/quarto-dev/quarto-cli/issues/3603
soils::make_ft("micro") |>
  # EDIT: adds border above merged unit cells.
  # may need to adjust column index
  soils::unit_hline(c(2))
```

```{r micro-plot-static}
#| eval: !expr out_type %in% c("pdf", "docx")
micro_plot <- soils::make_strip_plot(groups$micro, output = "static")
soils::save_plot(micro_plot, ext = "png", width = 6, height = 4)

knitr::include_graphics(
  paste0(
    here::here(), "/inst/figure_output/micro_plot.png"
  )
)
```

```{r micro-plot-tips, ref.label=I("plot-tips")}
```

```{r micro-plot-html}
#| eval: !expr out_type == "html"
#| fig-height: 6
soils::make_plotly(groups$micro)
```

```{r download-data-text}
#| eval: !expr out_type == "html"
#| results: asis
cat("## Download your data")
```

```{r download-data}
#| eval: !expr out_type == "html"
list(
  results = producer_samples,
  measurement_dictionary = dictionary[, c(
    "column_name",
    "measurement_full_name",
    "abbr",
    "unit"
  )]
) |>
  downloadthis::download_this(
    output_name = "soils_data",
    output_extension = ".xlsx",
    button_label = "Download as Excel spreadsheet",
    button_type = "success"
  )
```

## Looking Forward

\[INSERT SUMMARY INFORMATION AND A CALL TO ACTION\] *Consider describing how this data will be used. Are you building decision support tools? Publications? Will you be speaking at upcoming field days or conferences about this work? Soils data can be confusing... let your audience know that this is just the start of the conversation! Thank participating producers once again.*

## Acknowledgement

This Soil Health Report Template was developed by Washington State Department of Agriculture and Washington State University (WSU) as part of the Washington Soil Health Initiative. Text and figures were adapted from [WSU Extension publication #FS378E Soil Health in Washington Vineyards](https://pubs.extension.wsu.edu/soil-health-in-washington-vineyards "WSU Extension publication").

Please use the following citation when acknowledging our work:

| Ryan JN, McIlquham M, Sarpong KA, Michel L, Potter T, Griffin LaHue D, Gelardi DL. 2023. A Soil Health Report Template for Survey Studies. The Washington Soil Health Initiative. [washingtonsoilhealthinitiative.org](washingtonsoilhealthinitiative.org "washingtonsoilhealthinitiative.org")

```{js open-link-in-new-tab}

// https://yihui.org/en/2018/09/target-blank/

(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.leng; i) {
    if (/^(https?:)?\/\//.st(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
```
